---
title: "Babuk v4 Ransomware"
author: "Davide Bragetti"
date: 2022-08-15T12:51:45.141+0000
last_modified_at: 2023-08-01T17:56:17.302+0000
categories: [""]
tags: ["babuk","malware-analysis","ransomware","malware","raas"]
description: "Background summary and technical sample analysis"
image:
  path: /assets/e3a6a1939162/1*hm0UuYYti5dx_6HzMF1BNQ.png
render_with_liquid: false
---

### Babuk v4 Ransomware
#### Background summary and technical sample analysis

Babuk is a ransomware threat [discovered in 2021](https://twitter.com/arkbird_solg/status/1345569395725242373?s=21){:target="_blank"} that attacked at least five big enterprises\. The ransomware group behind it follows the Big\-Game hunting strategy as a modus operandi\.


![[The first tweet about Babuk ransomware](https://twitter.com/arkbird_solg/status/1345569395725242373?s=21){:target="_blank"}](/assets/e3a6a1939162/1*hwHo7jZsENEwPpjpFR8T7A.png)

[The first tweet about Babuk ransomware](https://twitter.com/arkbird_solg/status/1345569395725242373?s=21){:target="_blank"}

Right after the attack on Washington D\.C Police Department in April, the group announced they wanted to change direction, passing from RaaS to data\-theft extortion and eventually becoming open\-source\.

In September of the same year, the ransomware source code was leaked and became available to the broad public, advised by the notorious malware database vx\-underground:


![[vx\-underground advises the source code leak](https://mobile.twitter.com/vxunderground/status/1433758742244478982){:target="_blank"}](/assets/e3a6a1939162/1*muSDjoBE3pUM0zrO-YeQtQ.png)

[vx\-underground advises the source code leak](https://mobile.twitter.com/vxunderground/status/1433758742244478982){:target="_blank"}

The malware shares part of its codebase with _Vasa Locker_ , _Rook_ , and _DarkAngels_ ransomwares, and despite the group announcements, its encryption capabilities were enhanced, becoming more efficient during the whole year 2021\.


![Babuk codebase inheritance tree](/assets/e3a6a1939162/1*B8h5sVamTGyAdvVIJJva4A.jpeg)

Babuk codebase inheritance tree
### The sample :

We are going to perform **basic** and **advanced** **static analysis** of the sample **Babuk v4** , you can find it at this [link](https://bazaar.abuse.ch/sample/245e191bfe998ad9ef2d6b169af22f3c290e9950234f8ddd0f4a03cb3eebf761/){:target="_blank"} \.


> **MD5** : 
 

> a499f810c2e52fe9f8adcd5817b2d985
 

> **SHA256** : 245e191bfe998ad9ef2d6b169af22f3c290e9950234f8ddd0f4a03cb3eebf761 





Opening the sample with _pestudio_ , we notice that it is importing a wide selection of flagged functions\.


![pestudio imported functions tab](/assets/e3a6a1939162/1*QHxNAp9Bepgbl5210o03HA.png)

pestudio imported functions tab

The summary from [**_Cutter_**](https://www.radare.org/cutter/){:target="_blank"} **:**


![Cutter summary dashboard](/assets/e3a6a1939162/1*RCOG5yXu0jZ3Cgc9urM1ew.png)

Cutter summary dashboard


![**DIE** entropy tab](/assets/e3a6a1939162/1*dGFZciZyOymoSNYxZTo88Q.png)

**DIE** entropy tab

The static analysis done by _Detect It Easy_ suggests that the sample is **not packed** \. So we can search at the Symbols Tree and open the view to the decompiled code of the **entry0 function:**
```cpp
void entry0(void)
{
    char cVar1;
    undefined4 uVar2;
    int32_t iVar3;
    undefined4 lpSystemInfo;
    int32_t var_74h;
    int32_t var_64h;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    uint32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    undefined4 lpString1;
    uint32_t var_44h;
    uint32_t var_40h;
    uint32_t hObject;
    undefined4 var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    uint32_t lpHandles;
    int32_t var_18h;
    uint16_t *var_14h;
    int32_t var_10h;
    int32_t lpString2;
    int32_t lpString;
    uint32_t nCount;
    
    fcn.0040fde0();
    fcn.00412d80();
    *(int32_t *)0x414260 = fcn.00404a80();
    if (*(int32_t *)0x414260 != 0) {
        var_18h = 0;
        uVar2 = (*_GetCommandLineW)(&var_18h);
        var_38h = (*_CommandLineToArgvW)(uVar2);
        (*_SetProcessShutdownParameters)(0, 0);
        var_44h = fcn.00404c20(var_18h, var_38h, 0x403c18);
        if (var_44h != 0) {
            *(uint32_t *)0x414130 = var_44h;
            fcn.00404dc0(var_44h);
            *(int32_t *)0x41425c = 1;
        }
        fcn.00404770();
        fcn.004049b0();
        fcn.004046d0();
        (*_SHEmptyRecycleBinA)(0, 0, 7);
        (*_GetSystemInfo)(&lpSystemInfo);
        var_5ch = var_74h;
        var_54h = var_74h * 4;
        nCount = var_54h >> 1;
        fcn.00412e50(0x4141fc, var_74h * 0x18);
        fcn.00412e50(0x41422c, nCount * 3);
        lpHandles = fcn.00412e00(nCount << 2);
        var_20h = fcn.00412e00(nCount << 2);
        if ((lpHandles != 0) && (var_20h != 0)) {
            fcn.00412d90(lpHandles, 0, nCount << 2);
            fcn.00412d90(var_20h, 0, nCount << 2);
            for (var_24h = 0; (uint32_t)var_24h < nCount; var_24h = var_24h + 1) {
                uVar2 = (*_CreateThread)(0, 0, fcn.0040a7e0, 1, 0, 0);
                *(undefined4 *)(lpHandles + var_24h * 4) = uVar2;
                uVar2 = (*_CreateThread)(0, 0, fcn.0040a7e0, 0, 0, 0);
                *(undefined4 *)(var_20h + var_24h * 4) = uVar2;
            }
            lpString2 = fcn.00404c20(var_18h, var_38h, 0x403c24);
            lpString = fcn.00404c20(var_18h, var_38h, 0x403c34);
            if (lpString2 != 0) {
                var_2ch = 1;
                var_60h = (*_lstrlenW)(lpString2);
                for (var_28h = 0; var_28h < var_60h; var_28h = var_28h + 1) {
                    if (*(int16_t *)(lpString2 + var_28h * 2) == 0x2c) {
                        *(undefined2 *)(lpString2 + var_28h * 2) = 0;
                        var_2ch = var_2ch + 1;
                    }
                }
                do {
                    iVar3 = (*_lstrlenW)(lpString2);
                    lpString1 = fcn.00412e00(iVar3 * 2 + 2);
                    (*_lstrcpyW)(lpString1, lpString2);
                    fcn.0040a9a0(lpString1);
                    fcn.00412e30(lpString1);
                    iVar3 = (*_lstrlenW)(lpString2);
                    lpString2 = lpString2 + 2 + iVar3 * 2;
                    var_2ch = var_2ch + -1;
                } while (var_2ch != 0);
            }
            if (lpString != 0) {
                var_34h = 1;
                var_64h = (*_lstrlenW)(lpString);
                for (var_30h = 0; var_30h < var_64h; var_30h = var_30h + 1) {
                    if (*(int16_t *)(lpString + var_30h * 2) == 0x2c) {
                        *(undefined2 *)(lpString + var_30h * 2) = 0;
                        var_34h = var_34h + 1;
                    }
                }
                do {
                    iVar3 = (*_lstrlenW)(lpString);
                    var_14h = (uint16_t *)fcn.00412e00(iVar3 * 2 + 2);
                    (*_lstrcpyW)(var_14h, lpString);
                    iVar3 = (*_lstrlenW)(var_14h);
                    if ((iVar3 == 2) && (var_14h[1] == 0x3a)) {
                        fcn.0040aad0((uint32_t)*var_14h);
                    } else {
                        fcn.0040a5e0(var_14h);
                    }
                    fcn.00412e30(var_14h);
                    iVar3 = (*_lstrlenW)(lpString);
                    lpString = lpString + 2 + iVar3 * 2;
                    var_34h = var_34h + -1;
                } while (var_34h != 0);
            }
            if (((lpString == 0) && (lpString2 == 0)) && (iVar3 = (*_OpenMutexA)(0x1f0001, 0, 0x403c40), iVar3 == 0)) {
                (*_CreateMutexA)(0, 0, 0x403c60);
                var_58h = 0;
                cVar1 = fcn.00404b20(var_18h, var_38h, 0x403c80);
                if (cVar1 == '\x01') {
                    fcn.0040a8d0(var_58h);
                }
                fcn.004044a0();
                var_40h = (*_GetLogicalDrives)();
                if (var_40h != 0) {
                    for (var_10h._0_2_ = 0x41; (uint16_t)var_10h < 0x5b; var_10h._0_2_ = (uint16_t)var_10h + 1) {
                        if ((var_40h & 1) != 0) {
                            fcn.0040aad0((uint32_t)(uint16_t)var_10h);
                        }
                        var_40h = var_40h >> 1;
                    }
                }
                cVar1 = fcn.00404b20(var_18h, var_38h, 0x403c88);
                if (cVar1 == '\0') {
                    fcn.0040a8d0(var_58h);
                }
            }
            for (var_4ch = 0; (uint32_t)var_4ch < nCount; var_4ch = var_4ch + 1) {
                fcn.00412f70(0x41422c, 0, 1);
            }
            (*_WaitForMultipleObjects)(nCount, lpHandles, 1, 0xffffffff);
            for (var_50h = 0; (uint32_t)var_50h < nCount; var_50h = var_50h + 1) {
                fcn.00412f70(0x4141fc, 0, 1);
            }
            (*_WaitForMultipleObjects)(nCount, var_20h, 1, 0xffffffff);
            fcn.004046d0();
            for (hObject = 0; hObject < nCount; hObject = hObject + 1) {
                (*_CloseHandle)(*(undefined4 *)(lpHandles + hObject * 4));
                (*_CloseHandle)(*(undefined4 *)(var_20h + hObject * 4));
            }
            fcn.00412e30(lpHandles);
            fcn.00412e30(var_20h);
        }
        if (*(int32_t *)0x41425c != 0) {
            fcn.00404e00();
        }
        (*_CryptReleaseContext)(*(int32_t *)0x414260, 0);
    }
    (*_ExitProcess)(0);
    return;
}
```
### Advanced Static Analysis

After analyzing the malware code, we can divide the malware activities into the following phases:
- It will start by **obtaining the cryptographic key context** and will increase the process completion time of the computer shutdown process\.
- Later, it will **terminate** a predefined list of **services and processes,** **delete** **shadow copies** , and **empty** the **recycle bin** \.
- After that, it will **create** several **threads** \(which it will use to traverse and encrypt later\); it will **discover** **shared folders, network resources** , and **disks** to know what it can and cannot encrypt \(managing exclusion lists too\)
- Finally, it will **encrypt** **everything** and create the ransom file in each encrypted folder\.

### Obtaining Key Context

In the beginning, Babuk uses the _acquire\_CSP_ function that calls the _CryptAcquireContextW_ API to get an handle to a key container within a Cryptographic Service Provider \(CSP\) \.


![Babuk obtains the handle to the **CSP**](/assets/e3a6a1939162/1*f9Lo8YBSLKtWLZpQ5ZEOyw.png)

Babuk obtains the handle to the **CSP**

Next, the malware parses the command line arguments and calls the _SetProcessShutdownParameters_ API to increase the time the malware gets to execute in the compromised machine\.


![](/assets/e3a6a1939162/1*5LJFmOhWysXA87n5Tn7dTw.png)

### Terminating Services and Processes

Than Babuk attempts to close a predefined list of the **services** and **processes** :
#### **Services**


> vss, sql, svc, memtas, mepocs, sophos, veeam, backup, GxVss, GxBlr, GxFWD, GxCVD, GxCIMgr, DefWatch, ccEvtMgr, ccSetMgr, SavRoam, RTVscan, QBFCService, QBIDPService, Intuit\.QuickBooks\.FCS, QBCFMonitorService, YooBackup, YooIT, zhudongfangyu, sophos, stc\_raw\_agent, VSNAPVSS, VeeamTransportSvc, VeeamDeploymentService, VeeamNFSSvc, veeam, DVFSService, BackupExecVSSProvider, BackupExecAgentAccelerator, BackupExecAgentBrowser, BackupExecDiveciMediaService, BackupExecJobEngine, BackupExecManagementService, BackupExecRPCService, AcrSch2Svc, AcronisAgent, CASAD2DWebSvc, CAARCUpdateSvc\. 





The malware obtains a handle to the _SCManager_ with the function _OpenSCManagerA_ \. Then, it opens and checks the status of the services by calling _QueryServiceStatusEx_ \. If the service is still running, it will enumerate the services that depend on it by calling _EnumDependentServicesA_ , so it will first **stop** all the **dependent** **services** **and** finally the **targetted** **one** , always calling the ControlService function with the _SERVICE\_CONTROL\_STOP_ flag\.


![Babuk stops all the dependent services of the target service\.](/assets/e3a6a1939162/1*S1ufaYYZGItDrhO6VDIZAg.png)

Babuk stops all the dependent services of the target service\.
#### Processes


> sql\.exe, oracle\.exe, ocssd\.exe, dbsnmp\.exe, synctime\.exe, agntsvc\.exe, isqlplussvc\.exe, xfssvccon\.exe, mydesktopservice\.exe, ocautoupds\.exe, encsvc\.exe, firefox\.exe, tbirdconfig\.exe, mydesktopqos\.exe, ocomm\.exe, dbeng50\.exe, sqbcoreservice\.exe, excel\.exe, infopath\.exe, msaccess\.exe, mspub\.exe, onenote\.exe, outlook\.exe, powerpnt\.exe, steam\.exe, thebat\.exe, thunderbird\.exe, visio\.exe, winword\.exe, wordpad\.exe, notepad\.exe, 





Than Babuk uses _CreateToolhelp32Snapshot_ , _Process32FirstW_ , _Process32NextW_ , _OpenProcess_ , and _TerminateProcess_ to enumerate running processes and kill any found to match those in the hardcoded list\.


![Babuk terminates the processes matching the list\.](/assets/e3a6a1939162/1*W91xSBPGmDHGw-A7-4zVlg.png)

Babuk terminates the processes matching the list\.
#### Delete Shadow Copy

The malware’s following action is deleting the victim machine’s shadow volumes in this way:
- It disables system redirection using _Wow64DisableWow64FsRedirection,_
- Then calls _ShellExecuteW_ to execute the command **“cmd\.exe /c vssadmin\.exe delete shadows /all /quiet”** _,_ which removes the shadow volumes,
- Finally employs _Wow64RevertWow64FsRedirection_ to re\-enable file system redirection\.



![Babuk deletes the **shadow volumes**](/assets/e3a6a1939162/1*4dEo4B6bza7u0n-1vT9XqQ.png)

Babuk deletes the **shadow volumes**

Lastly, Babuk empties the content of recycle bin using the function _SHEmptyRecycleBinA_ **\.**


![Babuk empties the **recycle bin**](/assets/e3a6a1939162/1*nbuibdguB5JRHk73Oujezg.png)

Babuk empties the **recycle bin**
### Enumerating Shares, Paths and Resources
#### Shares

Babuk uses the optional arguments _shares_ to enumerate specific network shares\.


![Babuk parses command line arguments **shares** and **paths**](/assets/e3a6a1939162/1*ADJfvQ6VglK8MDoivBY-vQ.png)

Babuk parses command line arguments **shares** and **paths**

The share discovery employs the API _NetShareEnum,_ which returns an array of [SHARE\_INFO\_0](https://docs.microsoft.com/en-us/windows/desktop/api/lmshare/ns-lmshare-share_info_0){:target="_blank"} structures, then parses searching for _ADMIN$_ shares\.


![Babuk checks **ADMIN$ share**](/assets/e3a6a1939162/1*FWSH7KG6XpkXJLz92W91og.png)

Babuk checks **ADMIN$ share**

If the check is positive, it calls the _find\_paths\_recursive_ function, which operates partially like the _find\_files\_recurisive_ function _,_ pushing the path to the queue\. Then popping and encrypting the files it founds enqueued, proceeding with a recursive call in case it finds other directories\.


![**find\_paths\_recursive** routine push, pop and encrypt files](/assets/e3a6a1939162/1*uZMjt_twxmYis8S6qjOLoA.png)

**find\_paths\_recursive** routine push, pop and encrypt files
#### Paths

Babuk does the same with the command line argument _paths_ , used to explore specific filesystem locations, manipulating the path appropriately if it contains a Drive, and then using the _find\_paths\_recursive_ routine as in the previous case\.


![Babuk checks if the current path is a drive](/assets/e3a6a1939162/1*9XfotuD50nutSE7YwMjVFg.png)

Babuk checks if the current path is a drive
#### Mutex

After the enumeration of shares and paths, the malware checks and creates a mutex named _DoYouWantToHaveSexWithCuongDong_ to avoid starting the encryption if the target is already infected\.


![Babuck opens and creates a mutex](/assets/e3a6a1939162/1*vLpZQ1eyT_of150k2o3Kkg.png)

Babuck opens and creates a mutex
#### Resources

In the case attacker specifies the argument _sf_ in the command line, Babuk proceeds to enumerate network resources, using the _find\_files\_network_ that employs the standard Windows APIs _WNetOpenEnumW_ and _WNetEnumResourceW,_ calling the find\_files\_network and _find\_paths\_recursive_ routines recursively\.


![Babuk parses the **sf** argument](/assets/e3a6a1939162/1*Ig0Erlp-Q3CqC50PepbzsQ.png)

Babuk parses the **sf** argument


![**find\_files\_network** routine enumerate the resources](/assets/e3a6a1939162/1*cNlpLODi7YsHXtUIhiGAkw.png)

**find\_files\_network** routine enumerate the resources

Finally, Babuk waits for the encryption threads to terminate, calling the _WaitForMultipleObjects_ API, and deletes the _shadow copies_ again\.


![Babuck waits the threads and removes the shadow volumes](/assets/e3a6a1939162/1*3pDJMfBKC6_T7GpTBA9rHA.png)

Babuck waits the threads and removes the shadow volumes

Ultimately it closes the handles to the threads, releases the CSP, and exits, calling the Windows APIs _CloseHandle_ , _CryptoReleaseContext_ , and _ExitProcess\._


![Babuk closes the handles to the threads, then releases the CSP and exits\.](/assets/e3a6a1939162/1*PWb-D8gv1chfAkwZLDoiwQ.png)

Babuk closes the handles to the threads, then releases the CSP and exits\.
### Encrypt Everything
#### Threads and queue

Babuk computes the **number** of **threads** for discovering and encrypting the target files and **initializes** a **linked queue** it will use to store them\.


![Babuk creates the secondary threads](/assets/e3a6a1939162/1*Y1aiHkn4IPOOIQ38i9U3dQ.png)

Babuk creates the secondary threads

The above code is executed inside a loop and creates two threads for each iteration\. The thread points to the _babuk\_thread\_encrypt_ routine that takes one parameter; if its value is 1, the thread will attempt to find the files recursively and then starts the encryption; if its value is 0, it will just begin encrypting the files it finds in the queue\.


![The secondary threads start either encrypting or enumerating the files](/assets/e3a6a1939162/1*Nfp54OPnQeMc9fbKok63-A.png)

The secondary threads start either encrypting or enumerating the files

The following drawing shows the way Babuk manages the linked queue:


![The operations on the linked queue](/assets/e3a6a1939162/1*hm0UuYYti5dx_6HzMF1BNQ.png)

The operations on the linked queue

The _main thread_ and the _slaves_ push the clear\-text files that will encrypt on the queue head; other _slaves_ wait to pop them from the tail\. In the _find\_files\_recurisve_ function, **the _Master_** **and _slaves_** also **create** the **ransom** **note** file into the directory they traverse before the encryption unless the directory is in the **deny list** \.


![Babuk creates the file “How To Restore Your Files\.txt”](/assets/e3a6a1939162/1*faEnhUybQb9yVUALJLA16g.png)

Babuk creates the file “How To Restore Your Files\.txt”


![Babuk writes the hardcoded message to the file it just created](/assets/e3a6a1939162/1*XKPzlMYrzT1U2JEkPvCEug.png)

Babuk writes the hardcoded message to the file it just created
#### Ecryption

The encryption routine starts renaming the file that has to be encrypted by appending the _\.babyk_ extensions:


![Babuk renames the files by appending the “ **\.babyk”** extension\.](/assets/e3a6a1939162/1*Pkb6YHlLKRkPJlDClAH_TQ.png)

Babuk renames the files by appending the “ **\.babyk”** extension\.

Upon successfully renaming the file, the ransomware generates the victim’s public/private keys using the [_ChaCha_](https://www.cryptopp.com/wiki/HC-128){:target="_blank"} _HC\-128 ECDH_ algorithm\.
- First, it **obtains** the 32 random bytes **victim’s _secret key_** by calling _CryptGenRandom_ \(which uses the CSP handle\) \.



![Babuk generates 32 random bytes for the secret key](/assets/e3a6a1939162/1*Xp4em_Srd5EXS3PwxKKWFw.png)

Babuk generates 32 random bytes for the secret key
- **Then** , it **adjusts** the **_secret key_** with some “magic” bytes **and** **uses** the [_curve25519\_donna_](https://github.com/agl/curve25519-donna){:target="_blank"} **function** to **derive** the **victim’s _public key_** \(needed for the decryption\) _\._
- Finally **feeds** the **attacker’s _public key_** , which was hardcoded by the ransomware builder, **to** th _e [curve25519\_donna](https://github.com/agl/curve25519-donna){:target="_blank"}_ **function** , **obtaining** a **_shared key\._**
- **Hashing** the result **with** **SHA256** **provides** the **key** **for** **encrypting** the **files** with the **ChaCha** schema _\._



![Babuk sets up the cryptographic keys](/assets/e3a6a1939162/1*o5hA8zUHa6KSlViY9c_Qkg.png)

Babuk sets up the cryptographic keys

After the set up of the Keys, Babuk creates a structure to hold the encryption meta\-data \(victim’s public key and its crc32 checksum\) to be saved at the end of the encrypted file and proceeds to encrypt the files differentiating in 3 cases\.

The following encryption routine fragments compares the result of the _SetFilePointerEx_ function with the hex values 0x1400000 \(around 20 MB\), 0x500000 \(about 5 MB\), and 0 bytes to choose the size of the block to be encrypted\.


![Babuk checks the file size against the hardcoded constants](/assets/e3a6a1939162/1*L5Oi0IhgrgUJ3OAM6L-Ajg.png)

Babuk checks the file size against the hardcoded constants

But the routine does not change substantially: It always uses _ReadFile_ to read a variable amount of bytes in the target file, then encrypts the bytes by calling _chacha\_encrypt,_ and finally moves the pointer forwards\.


![Babuk reads bytes, encrypts, and moves the file pointer](/assets/e3a6a1939162/1*uvD8_aKBuzjie0gud-7xvQ.png)

Babuk reads bytes, encrypts, and moves the file pointer

Last but not least, the last fragment of the routine appends the meta\-data needed to decrypt the file\. That is to say: the **attackers** need to **save** the **victim’s** **_public_** _**key**_ to **recover** the **_shared_** _**secret**_ and **reproduce** the **_symmetric key\._**


![Babuk appends the victim’s public key to the file as metadata](/assets/e3a6a1939162/1*vnLXTtT1B_Giy7grQ8FN0A.png)

Babuk appends the victim’s public key to the file as metadata
### Last Remarks
#### Conclusions

Babuk is a simple ransomware in that it does not use any obfuscation to hide its IoCs and does not employ any evasion or anti\-analysis technique\. Moreover, security vendors know it, considering it shares its codebase with several other malicious campaigns; nevertheless, from the analysis, we had the chance to observe how RaaS software executes its TTPs during large\-scale campaigns\.
#### Yara Rule
```yara
rule BabukRansomwareV4 {
    meta:
        description = "YARA rule for Babuk Locker v.4 unpacked"
        reference = "https://medium.com/@dbragetti/babuk-v4-ransomware-e3a6a1939162"
        author = "@dbragetti"
        date = "2022-08-10"
        rule_version = "v1"
        malware_type = "Ransomware"
    strings:
        $arg_str1 = "shares" wide
        $arg_str2 = "paths" wide
        $arg_str3 = "sf" wide
        $str0= "delete shadows /all /quiet" wide
        $str2 = "How To Restore Your Files.txt" wide
        $str3 = "DoYouWantToHaveSexWithCuongDong"
        $str4 = ".babyk" wide
        $str5 = "ADMIN$" wide
        $pattern1 = {51003a005c00000057003a005c00000045003a005c00000052003a005c00000054003a005c00000059003a005c00000055003a005c00000049003a005c0000004f003a005c00000050003a005c00000041003a005c00000053003a005c00000044003a005c00000046003a005c00000047003a005c00000048003a005c0000004a003a005c0000004b003a005c0000004c003a005c0000005a003a005c00000058003a005c00000043003a005c00000056003a005c00000042003a005c0000004e003a005c0000004d003a005c000000}
    condition:
        all of ($str*) and all of ($arg_str*) and all of ($pattern*)
}
```
#### References


> [https://twitter\.com/arkbird\_solg/status/1345569395725242373](https://twitter.com/arkbird_solg/status/1345569395725242373){:target="_blank"} 





> [https://mobile\.twitter\.com/vxunderground/status/1433758742244478982](https://mobile.twitter.com/vxunderground/status/1433758742244478982){:target="_blank"} 





> [https://www\.mcafee\.com/enterprise/en\-us/assets/reports/rp\-babuk\-ransomware\.pdf](https://www.mcafee.com/enterprise/en-us/assets/reports/rp-babuk-ransomware.pdf){:target="_blank"} 





> [https://blog\.cyble\.com/2021/07/05/deep\-dive\-into\-builder\-of\-notorious\-babuk\-ransomware/](https://blog.cyble.com/2021/07/05/deep-dive-into-builder-of-notorious-babuk-ransomware/){:target="_blank"} 




