---
title: "Unpacking Malware"
author: "Davide Bragetti"
date: 2022-08-28T23:12:06.138+0000
last_modified_at: 2025-03-26T12:50:42.967+0000
categories: [""]
tags: ["malware-analysis","unpacking","upx","reverse-engineering"]
description: "In manual and automated ways"
image:
  path: /assets/685de7093e5/1*OGxGySb6sO2ATFo9cf15KA.png
pin: true
render_with_liquid: false
---

### Unpacking Malware
#### In manual and automated ways

Initially, Packers were just software born to protect developers’ intellectual property by hiding the inner mechanisms of software\. Nowadays, cybercriminals use them too to make malicious executables avoiding static detection by hiding the operations they will perform\. Many free packers are used to obfuscate malware, such as UPX, PE Protector, and MPRESS, to name a few, but malware developers also take care of this aspect by building custom routines to pack and unpack their precious creation\. These routines usually go by the name of Crypters, and unlike commercial packers, they are not “general\-purpose”, in that their unique objective is to pack and unpack the payload they have been created for\. There exists a similarity between encryption and packing; both enhance the entropy of the target data, avoid bit\-sequence repetition, and obtain a result that looks like random junk\. The difference is that packing usually expects data compression, so a reduction of the size of the executable\.

After being packed, a target executable is divided into at least two parts: an _unpacking stub_ , also called an “envelope”, and the actual compressed data\.


![](/assets/685de7093e5/1*gvcExt7yMX00VxKRCVr5bQ.png)


When started, a packed file would execute the unpacking stub that performs operations such as allocating new space, decrypting and copying further instructions, running those instructions, and so on, until the data composes the original file and can finally be executed\.


![](/assets/685de7093e5/1*OGxGySb6sO2ATFo9cf15KA.png)


Malware analysts developed several techniques to cope with packing, ranging from fully manual, semi\-automated, and fully automated\.
#### 1: Locating Tail \(or Section\) Jumps

Packers like UPX and MPRESS have in common that after the decompression routine, there is usually an inter\-section jump, so an instruction that moves the Instruction Pointer from one section to another, this could be accomplished by a jump or equivalent instruction, \(like push aex, return\) \.
#### 2: Intercepting “Signature\-Functions”

The packed executable often injects code in its or others’ process address space using a variety of Windows API calls\. Tracing manually or putting break\-points on these function calls is usually sufficient to locate the unpacked payloads\. This method can also identify which _covert execution_ technique the malware could attempt to use\. Of particular interest are all the API calls that can be used for _Getting the handle_ on the target process and for _Allocating_ , _Copying_ , _Altering_ _Permissions_ , and _Triggering_ the execution of memory regions\.
#### 3: Using Automated Tools

Malware analysts used their wits to build services able to automatically dissect and unpack malware\. Examples of these are from the work of @hasherezade [pe\-sieve](https://github.com/hasherezade/pe-sieve/releases){:target="_blank"} / [hollow\-hunter](https://github.com/hasherezade/hollows_hunter){:target="_blank"} and [mal\_unpack](https://github.com/hasherezade/mal_unpack){:target="_blank"} , or [unpac\.me](https://www.unpac.me/#/){:target="_blank"} ,
The founding Idea used by these kind tools is diverse, for example in the case of pe\-sieve and derivates the main idea is


> to detect code overwritten in memory by comparing it with the executable on disk 





while [pandare](https://docs.panda.re/){:target="_blank"} , uses whole system analysis to spot changes in entropy in processes and dump the corresponding memory sections\.
### The Sample

In this blog post we are going to unpack a sample of the **RedLineStealer** malware you can find at this [link](https://bazaar.abuse.ch/sample/3215decffc40b3257ebeb9b6e5c81c45e298a020f33ef90c9418c153c6071b36/){:target="_blank"} \. The use of a VM is highly recomanded, since in the **_Automated Tools_** chapter we need to start an infection, possibly collecting second stage payloads from the internet\.


> **MD5** : 
 

> 618ea7b0e2a26f3c6db0a8664c63fc6f
 

> **SHA256** : 3215decffc40b3257ebeb9b6e5c81c45e298a020f33ef90c9418c153c6071b36 





**Pestudio** is not able to recover any function imported by the sample, a sign that it is in fact packed\.


![](/assets/685de7093e5/1*BlwXL3HTglmlFWJ2wyMYEQ.png)


Looking in the file\-header we can notice the usual name used by UPX for its sections\.


![](/assets/685de7093e5/1*j3f55tpF6k3CDpX-sxfKEQ.png)

#### Locating Tail \(or Section\) Jumps

We can expect the Unpacking Stub to jump into another section for executing the unpacked code, so we are searching for a jump instruction that could also be indirect but, in our case with UPX, will be direct\. In this case, we can let our eyes help us by looking at the code\-graph arrows between code blocks\.

In particular, we are searching for jumps from the entry point section to any other section, and we can check which section the program starts by looking at the Functions window\. Instead, in in the Segments window \(View→Open Subviews → Segments\), we can learn what the address ranges for the sections are, which is a piece of very precious information for our search\.


![](/assets/685de7093e5/1*rxyTH8G3CMB4dG_s01ZlIQ.png)


We can see that section UPX1, where we are now, is not that huge \(from 729000 to 8E5000\), so we might expect the TAIL JUMP into another section\.
By the end of the graph representation of _sub\_8E4800_ method, we can notice the direct jump to an address in the UPX0 section\.


![](/assets/685de7093e5/1*6WEwmhDjhBkaDXxkoIsuHw.png)


From a rapid look to the target address we see very clearly that we are at the end of the UPX0 section, and the disassembler was not able to decode any instruction in it\.


![](/assets/685de7093e5/1*cNNxNnMvFSOzORVgjjen0w.png)


From a quick look at the target address, we clearly see that we are at the end of the UPX0 section, and the disassembler could not decode any instructions\.
We can put a breakpoint on that jump and let the debugger run to validate this hypothesis\. After the breakpoint is hit, we make IDA re\-analyze the program with the menu option: Options — General — Analysis — Reanalyze Program — Ok\.


![](/assets/685de7093e5/1*ulm7eIOTftJYtTSDnmkktA.png)


Now it’s time to use Scylla to dump the memory and reconstruct the IAT\.
Open Scylla and select the process IDA is debugging


![](/assets/685de7093e5/1*xgSXA2hAtb-YW-QJAIEVcw.png)


Then set the Original Entry Point \(OEP\) to the target address of the tail jump \(45FDF0\), or even of the tail jump instruction itself, then press IAT Autosearch and Get Imports,


![](/assets/685de7093e5/1*DZ3Q3zaNXezwkUnoP15Zgw.png)


Finally, we can press _Dump_ to save the new PE and _Fix Dump_ to adjust the raw size\. Finally, by opening the dumped file, we can recognize the main routines of **RedLineStealer\.**


![](/assets/685de7093e5/1*9hQbiXyDDR-0iPJUXQ0dvA.png)

#### Intercepting “Signature\-Functions”

This method could be thought of as a general method for debugging malware searching for payloads, which could be either PEs, DLLs, or Shellcodes\.

Depending on the Process Injection Technique we are looking for, we would put breakpoints on different sets of API calls\. Examples could be setting breakpoints on _OpenProcess_ , _VirtualAllocEx_ , _WriteProcessMemory,_ and _CreateRemoteThread_ for **process injection** , or on _CreateProcess_ , _ZwCreateSection_ , _ZwQueryInformationProcess_ , _ReadProcessMemory_ , _ZwMapViewOfSection_ , _GetCurrentProcess_ , _WriteprocessMemory,_ and _ResumeThread_ for **Process Hollowing\.**

In our case, we could limit the search to _LocalAlloc, VirtualAlloc_ , _VirtualProtect_ , and _CreateProcessInternalW,_ hoping that UPX will resolve and use these dynamically\. For doing it, we use x64dbg for opening the sample, run until the EntryPoint and add the breakpoints using the console\.


> **_bp LocalAlloc_** 





> **_bp VirtualAlloc_** 





> **_bp VirtualProtect_** 





> **_bp CreateProcessInternalW_** 





In this case, with UPX this method is not that fruitful, so we will see it better in a later post\.
#### Using Automated Tools:

To demonstrate the power of automated tools, we will use [pe\-sieve](https://github.com/hasherezade/pe-sieve/releases){:target="_blank"} \. You can install it using chocolately:


> choco install pesieve 





After downloading the sample, we can run it so that we can take note of the PID\.


![](/assets/685de7093e5/1*eHf2guwgoQNDWhSM2RACUw.png)


Next, we run pe\-sieve, specifying the /pid and /imp arguments used to target the desired process and attempt to reconstruct the IAT\.


> pe\-sieve\.exe /pid 192 /imp 5 





Pe\-sieve is going to create a folder with the memory dumps it spotted during the analysis and a JSON file with the result:


![](/assets/685de7093e5/1*qQ0AmscvmozmrF4iIIC1GA.png)


Comparing the sample with the Dump, we can observe how the raw size of section UPX0 is changed from 0 to 32800 bytes\.


![](/assets/685de7093e5/1*S3g_xellRIphXXji93M09g.png)


Looking at the imports, we can observe that the IAT reconstruction process was so successful that we now also have visibility of the functions the malware resolves dynamically\.


![](/assets/685de7093e5/1*KmoxgVklHF72noJVp3mRbw.png)


To debug the sample, we need to fix the dumped sample’s entry point and set the sections as executable\. For the first actions, we can use [tiny\_tracer](https://github.com/hasherezade/tiny_tracer){:target="_blank"} , which will help us to track the section jumps\. Right\-clicking on the sample and selecting “Run with PIN \(Tiny Tracer\)” , will start to collect some execution artifacts, saving them into a “\.tag” file that we can open with _BareTail_ \.


![](/assets/685de7093e5/1*4SyuInQSGy9kS2roD31vRg.png)


So we can adjust the entry point\.


![](/assets/685de7093e5/1*cJ9x3NkuXsOVm5MLbE-FZQ.png)


Set both UPX0 and UPX1 as executable, and save the adjusted Dump\.


![](/assets/685de7093e5/1*D_t__NR8PV6wkAeNGl5CsQ.png)


Finally, we have a working unpacked executable that can be debugged\.
### Conclusions

In this post, we went through several ways of unpacking a **RedLineStealer** sample compressed with UPX, ranging from complete static code analysis with IDA to almost fully automated with PE\-sieve\. For more sophisticated packers, different procedures might be needed\. Hopefully, leveraging the power of many RE Engines like Ghidra, IDA, and BinaryNinja, that offer API access to their database to automate operation, even beginner analysts can tackle the unpacking of even more complex obfuscators\.
#### Further Readings:

[Snowy Days & The Malware Packing Ways \| Magic Bytes](https://web.archive.org/web/20241215175113/https://deluks2006.github.io/posts/snowy-days-and-the-malware-packing-ways/){:target="_blank"}
#### References:


> [https://www\.oreilly\.com/library/view/learning\-malware\-analysis/9781788392501/820e38b0\-43c1\-40d0\-93df\-3b4d66da91a8\.xhtml](https://www.oreilly.com/library/view/learning-malware-analysis/9781788392501/820e38b0-43c1-40d0-93df-3b4d66da91a8.xhtml){:target="_blank"} 





> [https://marcoramilli\.com/2020/10/09/how\-to\-unpack\-malware\-personal\-notes/](https://marcoramilli.com/2020/10/09/how-to-unpack-malware-personal-notes/){:target="_blank"} 





> [https://twitter\.com/mehunhoff/status/1562812877966192643](https://twitter.com/mehunhoff/status/1562812877966192643){:target="_blank"} 





> [https://speakerdeck\.com/hshrzd/pe\-sieve\-detecting\-hooking\-and\-code\-implants?slide=30](https://speakerdeck.com/hshrzd/pe-sieve-detecting-hooking-and-code-implants?slide=30){:target="_blank"} 





> [https://www\.youtube\.com/watch?v=eTt3QU0F7V0](https://www.youtube.com/watch?v=eTt3QU0F7V0){:target="_blank"} 





> [1055681 — MALWARE ANALYSIS AND INCIDENT FORENSICS \| Catalogo dei Corsi di studio](https://corsidilaurea.uniroma1.it/it/view-course-details/2019/29389/20200316152528/0323bed7-8fbd-40a4-8a68-0471e78c8d2e/fe6d2256-d208-4e3e-8d34-9cbd9eb7fbe8/5121d76f-8076-418c-8ab4-57b191fede2a/52aa4642-de9c-4e48-bf7c-6e9eb991e862?guid_cv=fe6d2256-d208-4e3e-8d34-9cbd9eb7fbe8&current_erogata=0323bed7-8fbd-40a4-8a68-0471e78c8d2e){:target="_blank"} 






_[Post](https://medium.com/@dbragetti/unpacking-malware-685de7093e5){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
