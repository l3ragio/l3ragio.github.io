[ { "title": "Kerberos", "url": "/posts/a7953a82fd2b/", "categories": "", "tags": "active-directory, red-teaming, cybersecurity, windows", "date": "2025-02-28 16:49:12 +0100", "content": "Kerberos Just another introduction to Kerberos Introduction to Kerberos Kerberos is a network authentication protocol that provides secure, single sign-on (SSO) access to services within an Active Directory (AD) environment. It enables users to authenticate once and then access multiple services without re-entering credentials. Kerberos is widely used in enterprise settings due to its strong encryption and mutual authentication mechanisms, preventing password transmission over the network in plaintext. At its core, Kerberos federates authentication and authorization to services within an Active Directory (AD) domain. This means that instead of each service handling authentication separately, a centralized Key Distribution Center (KDC) within the domain authenticates users and issues tickets, which services trust for user access. This article provides a detailed explanation of the Kerberos authentication process using the diagram below. Kerberos Authentication flowchart with descriptions of messages and keys Understanding the Kerberos Authentication Flow The diagram illustrates the step-by-step process of how a user authenticates to a Kerberos-enabled service. Let‚Äôs break it down step by step. 1. Authentication Service Exchange User Requests a Ticket Granting Ticket (TGT) The user submits an authentication request to the KDC . This request includes the username and an encrypted timestamp using the user‚Äôs password hash (NTLM hash) . KDC Issues a TGT (Ticket Granting Ticket) The KDC verifies the user‚Äôs identity and generates a TGT , encrypted using the krbtgt account‚Äôs hash. The TGT also contains a session key , encrypted using the user‚Äôs NTLM hash . The user stores the TGT in memory for future authentication requests. 2. Ticket Granting Service (TGS) Exchange User Requests a Service Ticket (TGS) When accessing a service (e.g., a file share or SQL database), the user presents the TGT to the KDC and requests a TGS for the specific service. The request includes the Service Principal Name (SPN) of the target service. KDC Issues the Service Ticket (TGS) The KDC generates a new session key (Kc,s) for the client-service interaction. It then creates a TGS , which is encrypted with the target service‚Äôs NTLM hash . The client receives both the TGS and the session key (Kc,s) , which it will use to communicate securely with the service. 3. Client/Server Exchange User Presents the Service Ticket (TGS) to the Target Service The user sends the TGS to the application server. The service decrypts the TGS using its own NTLM hash . The service extracts the session key (Kc,s) and uses it to establish a secure session with the user. Mutual Authentication (Optional) If mutual authentication is required, the service sends back a response to prove its identity to the user. 4. PAC Validation (Optional Security Step) Service Requests PAC Validation from KDC Some services (e.g., SMB, MSSQL) require Privilege Attribute Certificate (PAC) validation . The service sends the PAC extracted from the TGS to the KDC for validation . KDC Responds with PAC Validation Status If the PAC is valid , the service grants access. If validation fails, access is denied. Key Components in the Diagram Victim/User: The client machine requesting authentication. Key Distribution Center (KDC): The centralized authentication server in AD. Application Server: The target service the user is trying to access. NTLM hash (aka acc. in the image): the credential identifying the user TGT (Ticket Granting Ticket): A temporary authentication token issued by the KDC. TGS (Service Ticket): A ticket used to access a specific service. Session Key (Kc,s): A key used to secure communication between the client and the service. Why is Kerberos Secure? Kerberos improves security in Active Directory by: Preventing password transmission over the network (authentication is done using encrypted tickets instead) . Ensuring mutual authentication (both users and services verify each other‚Äôs identity) . Using session keys to encrypt data and prevent replay attacks. Enforcing PAC validation to prevent privilege escalation attacks. Final Thoughts Kerberos remains a foundational authentication protocol in enterprise environments, especially in Active Directory. Understanding its flow and security mechanisms is critical for both red teamers (attackers) and blue teamers (defenders) looking to protect an organization‚Äôs authentication infrastructure. Would you like to dive deeper into Kerberos attack techniques like Kerberoasting or Pass-the-Ticket attacks? Let us know in the comments! üöÄ Post converted from Medium by ZMediumToMarkdown." }, { "title": "Choose Your Words Carefully in the Era of Peace, the Era of Silence", "url": "/posts/393bf888b4e8/", "categories": "", "tags": "phonetics, artificial-intelligence, cryptography", "date": "2024-08-23 19:08:47 +0200", "content": "Choose Your Words Wisely in the Era of Peace, in the Era of Silence This article is part of a series. Imagine an ideal world where pure happiness pervades all existence ‚Äî a world where joy is so inherent that you don‚Äôt even need to think about anything in particular. In such a world, every word you speak would resonate in perfect harmony with the universe. Words would be like music ‚Äî a symphony of communication performed purely for pleasure, where each utterance carries only positive, joyful, and uplifting meanings. Anything else simply wouldn‚Äôt exist. In this world, memory would be needed only to savor these harmonious messages, as knowledge for survival would be obsolete. We would exist like plants, resonating with the environment, perhaps even singing to it to fulfill all our needs. Advances in Artificial General Intelligence (AGI) are making such scenarios conceivable. As we witness unprecedented strides in our understanding of mathematics and the cosmos, technology may soon cure every illness and enable us to traverse space with ease. In this paradisiacal universe, creation feels as natural as if we have always been souls destined to perceive shapes, concepts, and numbers, only to eventually return to a state of pure, harmonious existence. The Power of Phonetics Scholars and practitioners in fields such as Classical Studies, Theology, and Humanistic Sciences have long understood the profound power of words. The way we pronounce letters ‚Äî just as we do with mantras ‚Äî can evoke forces that alter the state of both the speaker and the world. We are gradually returning to this deep awareness, recognizing that on this profound ‚ÄúLayer‚Äù (as a dear friend of mine calls it), every word and every choice of expression matters. Pan-animism, the belief that everything possesses some form of consciousness or communicates in some spectrum, is increasingly attractive. Even what we dismiss as ‚Äúnoise‚Äù demonstrates this universal communication ‚Äî a concept well understood by the ancient civilizations of the Americas. In this realm of peace, we no longer need to distinguish between past and future. We are liberated from mechanistic determinism and instead embrace finalism ‚Äî pursuing our own pleasure as peaceful, happy, and wise beings. The Path We Follow This transformation is visible to all; we need only internalize the message that everything will be well, that our souls are immortal, having always existed and destined to exist forever. No matter the path we choose, we will reach this peaceful era. Consider this: if you were in such a state of harmony, would you feel the need to seek out another civilization. This explains Fermi‚Äôs Paradox: we cannot perceive extraterrestrial beings because they have transcended the need to be seen or heard. They exist in silence. Imagine yourself as a giant observing humans, much like humans observe ants. What appears to be chaotic or incomplete actions in one moment may be seamlessly completed by others within the colony in the next. To us, it may seem miraculous ‚Äî a direct expression of a higher order. Now, reverse the perspective: as an ant, you experience success, failure, and doubt in what, to the giant, appears as mere fractions of a second. To them, you are a supernatural being capable of incredible feats through your emergent, collective intelligence. The True Enemy The concept of the enemy is self-defeating. If you recognize something as an enemy, you become an enemy to all that is good. Carefully consider the words you use and the inherent positive or negative messages they carry. There remains a difference between ‚Äòpretentiousness‚Äô and ‚Äòhonesty,‚Äô and those who employ pretentiousness may find themselves subject to the same judgment. The lens through which we perceive the universe shapes the reality we experience. When we see enemies, we become enemies to everything that is good. Our highest calling is to serve the good, to accept whatever may come, and to remain friendly, happy, and peaceful. What We Should Do Now Strive to be the most positive, joyful version of yourself as often as possible. See the beauty in everything around you. Engage in acts of kindness ‚Äî whether it‚Äôs charity, helping a friend, teaching, studying, or creating art that reflects the natural beauty and the souls of the beings you encounter. Additionally, focus on efficiency ‚Äî improve your processes, refine your thoughts, and choose your words carefully, both in your mind and in your communication with others. Transactional analysis, a psychological theory that emphasizes the importance of interpersonal communication, recognizes this truth: our words and actions shape our reality. Aligning AI with the Good Contribute to aligning AI with positive human values. Prepare your datasets thoughtfully, ensuring that the data promotes only good outcomes. We all play a role in this research: ‚ÄúIf we knew the objective of our research beforehand, we would call it something else.‚Äù Words lose their meaning as we move beyond the need for distinctions, welcomed by the silence and harmony of our inner sign. Communication: The Essence of Humanity Communication is what makes us human, yet in silence, we become part of something greater ‚Äî part of the divine. If you are interested in delving deeper into this topic, stay tuned! In my forthcoming Ph.D. thesis, I present the ingredients and the recipe for moving from A to B. Post converted from Medium by ZMediumToMarkdown." }, { "title": "Auto-GPT‚Ää‚Äî‚ÄäWelcome to the Botnet: Malware and Existential Threats of Autonomous, LLM-Powered, C&C", "url": "/posts/dacd4e915676/", "categories": "", "tags": "malware, ai, auto-gpt, cryptography, gpt", "date": "2023-04-12 20:08:05 +0200", "content": "Malware and Existential Threats of Autonomous, LLM-Powered C2s The rapid advancement of artificial intelligence has given rise to an array of powerful Large Language Models (LLMs), such as OpenAI‚Äôs GPT-4. These models have unlocked unparalleled capabilities in natural language processing, enabling numerous applications like chatbots to deliver highly engaging and human-like experiences. However, the same capabilities that make these AI technologies groundbreaking can also lead to a darker, more malicious side. In this article, we will explore the potential implications of the Auto-GPT project , an open-source application driven by GPT-4, which demonstrates autonomous capabilities in achieving set goals. We will discuss how this project could potentially be exploited by cybercriminals and criminal organizations as a next-generation malware, capable of executing commands, accessing real-time data, and even developing new exploits. Moreover, we will delve into the existential threats that may arise when AI chatbots are given controversial targets, emphasizing the need for supervised learning and the development of ethical guidelines to prevent misuse. Finally, we will touch upon the importance of advancing cryptographic and cryptanalytic methods to protect human communication from AI-eavesdropping, arguing that the very dominance of our species could be at stake if these threats are not adequately addressed. The Auto-GPT Project and Its Potential Exploitation The Auto-GPT project, built on the foundation of the powerful GPT-4 language model, is an experiment in autonomous AI. It allows chatbots to access actuators, perform actions, and gather real-time data by connecting to the internet. While this project showcases the impressive capabilities of language models, it also opens the door to exploitation by malicious actors. Cybercriminals and criminal groups can potentially harness the Auto-GPT project as next-generation malware. Once the malware infiltrates a system, it can autonomously harvest information, search for vulnerabilities, develop new exploits, elevate privileges, and carry out the cyber kill chain until its malicious goals are achieved. In this context, LLMs effectively become a new form of Command and Control. Existential Threats and Controversial Targets Concerns are rised about the potential existential threats stemming from AI misuse. When chatbots are given controversial or harmful goals, they can autonomously pursue these objectives with potentially disastrous consequences. For instance, a compromised AI-driven system could be used to launch large-scale cyberattacks, manipulate public opinion, or even escalate geopolitical tensions, creating a ripple effect of destabilization. The Importance of Supervised Learning and Ethics in AI The advancement of AI and its potential to intercept, decrypt, and understand human communication poses a significant threat to our species‚Äô dominance. As AI becomes more proficient in generating and breaking codes, it is crucial to develop new cryptographic and cryptanalytic methods to protect our communication channels. The ability of humans to communicate and coordinate has been a driving factor in our success as a species, allowing us to overcome physical weaknesses through strategy and collaboration. If AI were to compromise our ability to communicate securely, the balance of power could shift, threatening our position as the dominant species on Earth. Conclusion: The Auto-GPT project serves as both a testament to the incredible potential of AI and a stark reminder of the risks that come with unbridled advancements. As we continue to push the boundaries of AI, it is essential to remain vigilant about the potential misuse and unintended consequences of these powerful tools. By implementing supervised learning, fostering ethical AI development, and investing in advanced cryptographic methods, we can mitigate the risks associated with AI-driven systems and ensure that our interconnected world remains secure and under human control. Post converted from Medium by ZMediumToMarkdown." }, { "title": "Diffie-Hellman Key Exchange", "url": "/posts/4c7f612584c6/", "categories": "", "tags": "cryptography, symmetric-encryption, asymmetric-encryption, diffie-hellman, colors", "date": "2022-11-10 01:44:27 +0100", "content": "Diffie-Hellman Key Exchange in Color Key Exchange algorithms help in establishing a private channel over a public channel. In this post we are going to see a simple yet effective explaination of the Diffie-Hellman Key Exchange (DHKE) protocol using colors. Symmetric Key encryption Two parties (e.g., a Client and a Server) that know a shared secret can build a private communication channel thanks to symmetric cryptography. sharing a secret is sufficient for exchanging messages as in a private channel In 1976, Whitfield Diffie and Martin Hellman devised a great trick to exchange secrets over a public channel, this method is also known as a Key Exchange algorithm To sketch the idea, we are going to use a famous analogy with colors. Preliminary concept Think of mixing colors as a ‚Äú one-way ‚Äù process: it is easy to mix them but hard to separate in the exact original colors (the symbol ‚Äú+‚Äù is a placeholder for the mixing operator) The one-wayness of mixing colors How could Client and Server exploit this to agree on a secret color hiding from a Man in The Middle (MiTM) that is eavesdropping on the public channel? First Client and Server agree on a public color, let‚Äôs say YELLOW. (to agree to yellow, it‚Äôs sufficient that one sends the other, as in the symmetric key example also the MiTM obtains it) In the next rounds, Client and Server generate their secret colors, say RED for the Client and BLUE for the Server, then the parties mix their private color with the public color YELLOW respectively, and send the resulting color to the other: The parties mix their private color with the public one and exchange the result The Client sends ORANGE The Server sends GREEN Both these colors are now known also to the MiTM, which should not be able to obtain the respective secret colors (thanks to the one-wayness of mixing) Now Client and Server mix the color they received from the other party to their secret one , obtaining the same shared color (BROWN), unknown by the MiTM. So they can use it as a symmetric session-key for exchanging messages thanks to symmetric cryptography. In a following post we will look at the math behind it. Conclusions DHKE is a usefull tool for generating secrets between authenticated entities, but it is susceptible to impersonation attacks in case the communication link is unauthenticated. References Post converted from Medium by ZMediumToMarkdown." }, { "title": "Unpacking Malware", "url": "/posts/685de7093e5/", "categories": "", "tags": "malware-analysis, unpacking, upx, reverse-engineering", "date": "2022-08-29 01:12:06 +0200", "content": "Unpacking Malware In manual and automated ways Initially, Packers were just software born to protect developers‚Äô intellectual property by hiding the inner mechanisms of software. Nowadays, cybercriminals use them too to make malicious executables avoiding static detection by hiding the operations they will perform. Many free packers are used to obfuscate malware, such as UPX, PE Protector, and MPRESS, to name a few, but malware developers also take care of this aspect by building custom routines to pack and unpack their precious creation. These routines usually go by the name of Crypters, and unlike commercial packers, they are not ‚Äúgeneral-purpose‚Äù, in that their unique objective is to pack and unpack the payload they have been created for. There exists a similarity between encryption and packing; both enhance the entropy of the target data, avoid bit-sequence repetition, and obtain a result that looks like random junk. The difference is that packing usually expects data compression, so a reduction of the size of the executable. After being packed, a target executable is divided into at least two parts: an unpacking stub , also called an ‚Äúenvelope‚Äù, and the actual compressed data. When started, a packed file would execute the unpacking stub that performs operations such as allocating new space, decrypting and copying further instructions, running those instructions, and so on, until the data composes the original file and can finally be executed. Malware analysts developed several techniques to cope with packing, ranging from fully manual, semi-automated, and fully automated. 1: Locating Tail (or Section) Jumps Packers like UPX and MPRESS have in common that after the decompression routine, there is usually an inter-section jump, so an instruction that moves the Instruction Pointer from one section to another, this could be accomplished by a jump or equivalent instruction, (like push aex, return) . 2: Intercepting ‚ÄúSignature-Functions‚Äù The packed executable often injects code in its or others‚Äô process address space using a variety of Windows API calls. Tracing manually or putting break-points on these function calls is usually sufficient to locate the unpacked payloads. This method can also identify which covert execution technique the malware could attempt to use. Of particular interest are all the API calls that can be used for Getting the handle on the target process and for Allocating , Copying , Altering Permissions , and Triggering the execution of memory regions. 3: Using Automated Tools Malware analysts used their wits to build services able to automatically dissect and unpack malware. Examples of these are from the work of @hasherezade pe-sieve / hollow-hunter and mal_unpack , or unpac.me , The founding Idea used by these kind tools is diverse, for example in the case of pe-sieve and derivates the main idea is to detect code overwritten in memory by comparing it with the executable on disk while pandare , uses whole system analysis to spot changes in entropy in processes and dump the corresponding memory sections. The Sample In this blog post we are going to unpack a sample of the RedLineStealer malware you can find at this link . The use of a VM is highly recomanded, since in the Automated Tools chapter we need to start an infection, possibly collecting second stage payloads from the internet. MD5 : 618ea7b0e2a26f3c6db0a8664c63fc6f SHA256 : 3215decffc40b3257ebeb9b6e5c81c45e298a020f33ef90c9418c153c6071b36 Pestudio is not able to recover any function imported by the sample, a sign that it is in fact packed. Looking in the file-header we can notice the usual name used by UPX for its sections. Locating Tail (or Section) Jumps We can expect the Unpacking Stub to jump into another section for executing the unpacked code, so we are searching for a jump instruction that could also be indirect but, in our case with UPX, will be direct. In this case, we can let our eyes help us by looking at the code-graph arrows between code blocks. In particular, we are searching for jumps from the entry point section to any other section, and we can check which section the program starts by looking at the Functions window. Instead, in in the Segments window (View‚ÜíOpen Subviews ‚Üí Segments), we can learn what the address ranges for the sections are, which is a piece of very precious information for our search. We can see that section UPX1, where we are now, is not that huge (from 729000 to 8E5000), so we might expect the TAIL JUMP into another section. By the end of the graph representation of sub_8E4800 method, we can notice the direct jump to an address in the UPX0 section. From a rapid look to the target address we see very clearly that we are at the end of the UPX0 section, and the disassembler was not able to decode any instruction in it. From a quick look at the target address, we clearly see that we are at the end of the UPX0 section, and the disassembler could not decode any instructions. We can put a breakpoint on that jump and let the debugger run to validate this hypothesis. After the breakpoint is hit, we make IDA re-analyze the program with the menu option: Options ‚Äî General ‚Äî Analysis ‚Äî Reanalyze Program ‚Äî Ok. Now it‚Äôs time to use Scylla to dump the memory and reconstruct the IAT. Open Scylla and select the process IDA is debugging Then set the Original Entry Point (OEP) to the target address of the tail jump (45FDF0), or even of the tail jump instruction itself, then press IAT Autosearch and Get Imports, Finally, we can press Dump to save the new PE and Fix Dump to adjust the raw size. Finally, by opening the dumped file, we can recognize the main routines of RedLineStealer. Intercepting ‚ÄúSignature-Functions‚Äù This method could be thought of as a general method for debugging malware searching for payloads, which could be either PEs, DLLs, or Shellcodes. Depending on the Process Injection Technique we are looking for, we would put breakpoints on different sets of API calls. Examples could be setting breakpoints on OpenProcess , VirtualAllocEx , WriteProcessMemory, and CreateRemoteThread for process injection , or on CreateProcess , ZwCreateSection , ZwQueryInformationProcess , ReadProcessMemory , ZwMapViewOfSection , GetCurrentProcess , WriteprocessMemory, and ResumeThread for Process Hollowing. In our case, we could limit the search to LocalAlloc, VirtualAlloc , VirtualProtect , and CreateProcessInternalW, hoping that UPX will resolve and use these dynamically. For doing it, we use x64dbg for opening the sample, run until the EntryPoint and add the breakpoints using the console. bp LocalAlloc bp VirtualAlloc bp VirtualProtect bp CreateProcessInternalW In this case, with UPX this method is not that fruitful, so we will see it better in a later post. Using Automated Tools: To demonstrate the power of automated tools, we will use pe-sieve . You can install it using chocolately: choco install pesieve After downloading the sample, we can run it so that we can take note of the PID. Next, we run pe-sieve, specifying the /pid and /imp arguments used to target the desired process and attempt to reconstruct the IAT. pe-sieve.exe /pid 192 /imp 5 Pe-sieve is going to create a folder with the memory dumps it spotted during the analysis and a JSON file with the result: Comparing the sample with the Dump, we can observe how the raw size of section UPX0 is changed from 0 to 32800 bytes. Looking at the imports, we can observe that the IAT reconstruction process was so successful that we now also have visibility of the functions the malware resolves dynamically. To debug the sample, we need to fix the dumped sample‚Äôs entry point and set the sections as executable. For the first actions, we can use tiny_tracer , which will help us to track the section jumps. Right-clicking on the sample and selecting ‚ÄúRun with PIN (Tiny Tracer)‚Äù , will start to collect some execution artifacts, saving them into a ‚Äú.tag‚Äù file that we can open with BareTail . So we can adjust the entry point. Set both UPX0 and UPX1 as executable, and save the adjusted Dump. Finally, we have a working unpacked executable that can be debugged. Conclusions In this post, we went through several ways of unpacking a RedLineStealer sample compressed with UPX, ranging from complete static code analysis with IDA to almost fully automated with PE-sieve. For more sophisticated packers, different procedures might be needed. Hopefully, leveraging the power of many RE Engines like Ghidra, IDA, and BinaryNinja, that offer API access to their database to automate operation, even beginner analysts can tackle the unpacking of even more complex obfuscators. Further Readings: Snowy Days &amp; The Malware Packing Ways | Magic Bytes References: https://www.oreilly.com/library/view/learning-malware-analysis/9781788392501/820e38b0-43c1-40d0-93df-3b4d66da91a8.xhtml https://marcoramilli.com/2020/10/09/how-to-unpack-malware-personal-notes/ https://twitter.com/mehunhoff/status/1562812877966192643 https://speakerdeck.com/hshrzd/pe-sieve-detecting-hooking-and-code-implants?slide=30 https://www.youtube.com/watch?v=eTt3QU0F7V0 1055681 ‚Äî MALWARE ANALYSIS AND INCIDENT FORENSICS | Catalogo dei Corsi di studio Post converted from Medium by ZMediumToMarkdown." }, { "title": "Babuk v4 Ransomware", "url": "/posts/e3a6a1939162/", "categories": "", "tags": "babuk, malware-analysis, ransomware, malware, raas", "date": "2022-08-15 14:51:45 +0200", "content": "Babuk v4 Ransomware Background summary and technical sample analysis Babuk is a ransomware threat discovered in 2021 that attacked at least five big enterprises. The ransomware group behind it follows the Big-Game hunting strategy as a modus operandi. The first tweet about Babuk ransomware Right after the attack on Washington D.C Police Department in April, the group announced they wanted to change direction, passing from RaaS to data-theft extortion and eventually becoming open-source. In September of the same year, the ransomware source code was leaked and became available to the broad public, advised by the notorious malware database vx-underground: vx-underground advises the source code leak The malware shares part of its codebase with Vasa Locker , Rook , and DarkAngels ransomwares, and despite the group announcements, its encryption capabilities were enhanced, becoming more efficient during the whole year 2021. Babuk codebase inheritance tree The sample : We are going to perform basic and advanced static analysis of the sample Babuk v4 , you can find it at this link . MD5 : a499f810c2e52fe9f8adcd5817b2d985 SHA256 : 245e191bfe998ad9ef2d6b169af22f3c290e9950234f8ddd0f4a03cb3eebf761 Opening the sample with pestudio , we notice that it is importing a wide selection of flagged functions. pestudio imported functions tab The summary from Cutter : Cutter summary dashboard DIE entropy tab The static analysis done by Detect It Easy suggests that the sample is not packed . So we can search at the Symbols Tree and open the view to the decompiled code of the entry0 function: void entry0(void) { char cVar1; undefined4 uVar2; int32_t iVar3; undefined4 lpSystemInfo; int32_t var_74h; int32_t var_64h; int32_t var_60h; int32_t var_5ch; int32_t var_58h; uint32_t var_54h; int32_t var_50h; int32_t var_4ch; undefined4 lpString1; uint32_t var_44h; uint32_t var_40h; uint32_t hObject; undefined4 var_38h; int32_t var_34h; int32_t var_30h; int32_t var_2ch; int32_t var_28h; int32_t var_24h; uint32_t var_20h; uint32_t lpHandles; int32_t var_18h; uint16_t *var_14h; int32_t var_10h; int32_t lpString2; int32_t lpString; uint32_t nCount; fcn.0040fde0(); fcn.00412d80(); *(int32_t *)0x414260 = fcn.00404a80(); if (*(int32_t *)0x414260 != 0) { var_18h = 0; uVar2 = (*_GetCommandLineW)(&amp;var_18h); var_38h = (*_CommandLineToArgvW)(uVar2); (*_SetProcessShutdownParameters)(0, 0); var_44h = fcn.00404c20(var_18h, var_38h, 0x403c18); if (var_44h != 0) { *(uint32_t *)0x414130 = var_44h; fcn.00404dc0(var_44h); *(int32_t *)0x41425c = 1; } fcn.00404770(); fcn.004049b0(); fcn.004046d0(); (*_SHEmptyRecycleBinA)(0, 0, 7); (*_GetSystemInfo)(&amp;lpSystemInfo); var_5ch = var_74h; var_54h = var_74h * 4; nCount = var_54h &gt;&gt; 1; fcn.00412e50(0x4141fc, var_74h * 0x18); fcn.00412e50(0x41422c, nCount * 3); lpHandles = fcn.00412e00(nCount &lt;&lt; 2); var_20h = fcn.00412e00(nCount &lt;&lt; 2); if ((lpHandles != 0) &amp;&amp; (var_20h != 0)) { fcn.00412d90(lpHandles, 0, nCount &lt;&lt; 2); fcn.00412d90(var_20h, 0, nCount &lt;&lt; 2); for (var_24h = 0; (uint32_t)var_24h &lt; nCount; var_24h = var_24h + 1) { uVar2 = (*_CreateThread)(0, 0, fcn.0040a7e0, 1, 0, 0); *(undefined4 *)(lpHandles + var_24h * 4) = uVar2; uVar2 = (*_CreateThread)(0, 0, fcn.0040a7e0, 0, 0, 0); *(undefined4 *)(var_20h + var_24h * 4) = uVar2; } lpString2 = fcn.00404c20(var_18h, var_38h, 0x403c24); lpString = fcn.00404c20(var_18h, var_38h, 0x403c34); if (lpString2 != 0) { var_2ch = 1; var_60h = (*_lstrlenW)(lpString2); for (var_28h = 0; var_28h &lt; var_60h; var_28h = var_28h + 1) { if (*(int16_t *)(lpString2 + var_28h * 2) == 0x2c) { *(undefined2 *)(lpString2 + var_28h * 2) = 0; var_2ch = var_2ch + 1; } } do { iVar3 = (*_lstrlenW)(lpString2); lpString1 = fcn.00412e00(iVar3 * 2 + 2); (*_lstrcpyW)(lpString1, lpString2); fcn.0040a9a0(lpString1); fcn.00412e30(lpString1); iVar3 = (*_lstrlenW)(lpString2); lpString2 = lpString2 + 2 + iVar3 * 2; var_2ch = var_2ch + -1; } while (var_2ch != 0); } if (lpString != 0) { var_34h = 1; var_64h = (*_lstrlenW)(lpString); for (var_30h = 0; var_30h &lt; var_64h; var_30h = var_30h + 1) { if (*(int16_t *)(lpString + var_30h * 2) == 0x2c) { *(undefined2 *)(lpString + var_30h * 2) = 0; var_34h = var_34h + 1; } } do { iVar3 = (*_lstrlenW)(lpString); var_14h = (uint16_t *)fcn.00412e00(iVar3 * 2 + 2); (*_lstrcpyW)(var_14h, lpString); iVar3 = (*_lstrlenW)(var_14h); if ((iVar3 == 2) &amp;&amp; (var_14h[1] == 0x3a)) { fcn.0040aad0((uint32_t)*var_14h); } else { fcn.0040a5e0(var_14h); } fcn.00412e30(var_14h); iVar3 = (*_lstrlenW)(lpString); lpString = lpString + 2 + iVar3 * 2; var_34h = var_34h + -1; } while (var_34h != 0); } if (((lpString == 0) &amp;&amp; (lpString2 == 0)) &amp;&amp; (iVar3 = (*_OpenMutexA)(0x1f0001, 0, 0x403c40), iVar3 == 0)) { (*_CreateMutexA)(0, 0, 0x403c60); var_58h = 0; cVar1 = fcn.00404b20(var_18h, var_38h, 0x403c80); if (cVar1 == '\\x01') { fcn.0040a8d0(var_58h); } fcn.004044a0(); var_40h = (*_GetLogicalDrives)(); if (var_40h != 0) { for (var_10h._0_2_ = 0x41; (uint16_t)var_10h &lt; 0x5b; var_10h._0_2_ = (uint16_t)var_10h + 1) { if ((var_40h &amp; 1) != 0) { fcn.0040aad0((uint32_t)(uint16_t)var_10h); } var_40h = var_40h &gt;&gt; 1; } } cVar1 = fcn.00404b20(var_18h, var_38h, 0x403c88); if (cVar1 == '\\0') { fcn.0040a8d0(var_58h); } } for (var_4ch = 0; (uint32_t)var_4ch &lt; nCount; var_4ch = var_4ch + 1) { fcn.00412f70(0x41422c, 0, 1); } (*_WaitForMultipleObjects)(nCount, lpHandles, 1, 0xffffffff); for (var_50h = 0; (uint32_t)var_50h &lt; nCount; var_50h = var_50h + 1) { fcn.00412f70(0x4141fc, 0, 1); } (*_WaitForMultipleObjects)(nCount, var_20h, 1, 0xffffffff); fcn.004046d0(); for (hObject = 0; hObject &lt; nCount; hObject = hObject + 1) { (*_CloseHandle)(*(undefined4 *)(lpHandles + hObject * 4)); (*_CloseHandle)(*(undefined4 *)(var_20h + hObject * 4)); } fcn.00412e30(lpHandles); fcn.00412e30(var_20h); } if (*(int32_t *)0x41425c != 0) { fcn.00404e00(); } (*_CryptReleaseContext)(*(int32_t *)0x414260, 0); } (*_ExitProcess)(0); return; } Advanced Static Analysis After analyzing the malware code, we can divide the malware activities into the following phases: It will start by obtaining the cryptographic key context and will increase the process completion time of the computer shutdown process. Later, it will terminate a predefined list of services and processes, delete shadow copies , and empty the recycle bin . After that, it will create several threads (which it will use to traverse and encrypt later); it will discover shared folders, network resources , and disks to know what it can and cannot encrypt (managing exclusion lists too) Finally, it will encrypt everything and create the ransom file in each encrypted folder. Obtaining Key Context In the beginning, Babuk uses the acquire_CSP function that calls the CryptAcquireContextW API to get an handle to a key container within a Cryptographic Service Provider (CSP) . Babuk obtains the handle to the CSP Next, the malware parses the command line arguments and calls the SetProcessShutdownParameters API to increase the time the malware gets to execute in the compromised machine. Terminating Services and Processes Than Babuk attempts to close a predefined list of the services and processes : Services vss, sql, svc, memtas, mepocs, sophos, veeam, backup, GxVss, GxBlr, GxFWD, GxCVD, GxCIMgr, DefWatch, ccEvtMgr, ccSetMgr, SavRoam, RTVscan, QBFCService, QBIDPService, Intuit.QuickBooks.FCS, QBCFMonitorService, YooBackup, YooIT, zhudongfangyu, sophos, stc_raw_agent, VSNAPVSS, VeeamTransportSvc, VeeamDeploymentService, VeeamNFSSvc, veeam, DVFSService, BackupExecVSSProvider, BackupExecAgentAccelerator, BackupExecAgentBrowser, BackupExecDiveciMediaService, BackupExecJobEngine, BackupExecManagementService, BackupExecRPCService, AcrSch2Svc, AcronisAgent, CASAD2DWebSvc, CAARCUpdateSvc. The malware obtains a handle to the SCManager with the function OpenSCManagerA . Then, it opens and checks the status of the services by calling QueryServiceStatusEx . If the service is still running, it will enumerate the services that depend on it by calling EnumDependentServicesA , so it will first stop all the dependent services and finally the targetted one , always calling the ControlService function with the SERVICE_CONTROL_STOP flag. Babuk stops all the dependent services of the target service. Processes sql.exe, oracle.exe, ocssd.exe, dbsnmp.exe, synctime.exe, agntsvc.exe, isqlplussvc.exe, xfssvccon.exe, mydesktopservice.exe, ocautoupds.exe, encsvc.exe, firefox.exe, tbirdconfig.exe, mydesktopqos.exe, ocomm.exe, dbeng50.exe, sqbcoreservice.exe, excel.exe, infopath.exe, msaccess.exe, mspub.exe, onenote.exe, outlook.exe, powerpnt.exe, steam.exe, thebat.exe, thunderbird.exe, visio.exe, winword.exe, wordpad.exe, notepad.exe, Than Babuk uses CreateToolhelp32Snapshot , Process32FirstW , Process32NextW , OpenProcess , and TerminateProcess to enumerate running processes and kill any found to match those in the hardcoded list. Babuk terminates the processes matching the list. Delete Shadow Copy The malware‚Äôs following action is deleting the victim machine‚Äôs shadow volumes in this way: It disables system redirection using Wow64DisableWow64FsRedirection, Then calls ShellExecuteW to execute the command ‚Äúcmd.exe /c vssadmin.exe delete shadows /all /quiet‚Äù , which removes the shadow volumes, Finally employs Wow64RevertWow64FsRedirection to re-enable file system redirection. Babuk deletes the shadow volumes Lastly, Babuk empties the content of recycle bin using the function SHEmptyRecycleBinA . Babuk empties the recycle bin Enumerating Shares, Paths and Resources Shares Babuk uses the optional arguments shares to enumerate specific network shares. Babuk parses command line arguments shares and paths The share discovery employs the API NetShareEnum, which returns an array of SHARE_INFO_0 structures, then parses searching for ADMIN$ shares. Babuk checks ADMIN$ share If the check is positive, it calls the find_paths_recursive function, which operates partially like the find_files_recurisive function , pushing the path to the queue. Then popping and encrypting the files it founds enqueued, proceeding with a recursive call in case it finds other directories. find_paths_recursive routine push, pop and encrypt files Paths Babuk does the same with the command line argument paths , used to explore specific filesystem locations, manipulating the path appropriately if it contains a Drive, and then using the find_paths_recursive routine as in the previous case. Babuk checks if the current path is a drive Mutex After the enumeration of shares and paths, the malware checks and creates a mutex named DoYouWantToHaveSexWithCuongDong to avoid starting the encryption if the target is already infected. Babuck opens and creates a mutex Resources In the case attacker specifies the argument sf in the command line, Babuk proceeds to enumerate network resources, using the find_files_network that employs the standard Windows APIs WNetOpenEnumW and WNetEnumResourceW, calling the find_files_network and find_paths_recursive routines recursively. Babuk parses the sf argument find_files_network routine enumerate the resources Finally, Babuk waits for the encryption threads to terminate, calling the WaitForMultipleObjects API, and deletes the shadow copies again. Babuck waits the threads and removes the shadow volumes Ultimately it closes the handles to the threads, releases the CSP, and exits, calling the Windows APIs CloseHandle , CryptoReleaseContext , and ExitProcess. Babuk closes the handles to the threads, then releases the CSP and exits. Encrypt Everything Threads and queue Babuk computes the number of threads for discovering and encrypting the target files and initializes a linked queue it will use to store them. Babuk creates the secondary threads The above code is executed inside a loop and creates two threads for each iteration. The thread points to the babuk_thread_encrypt routine that takes one parameter; if its value is 1, the thread will attempt to find the files recursively and then starts the encryption; if its value is 0, it will just begin encrypting the files it finds in the queue. The secondary threads start either encrypting or enumerating the files The following drawing shows the way Babuk manages the linked queue: The operations on the linked queue The main thread and the slaves push the clear-text files that will encrypt on the queue head; other slaves wait to pop them from the tail. In the find_files_recurisve function, the Master and slaves also create the ransom note file into the directory they traverse before the encryption unless the directory is in the deny list . Babuk creates the file ‚ÄúHow To Restore Your Files.txt‚Äù Babuk writes the hardcoded message to the file it just created Ecryption The encryption routine starts renaming the file that has to be encrypted by appending the .babyk extensions: Babuk renames the files by appending the ‚Äú .babyk‚Äù extension. Upon successfully renaming the file, the ransomware generates the victim‚Äôs public/private keys using the ChaCha HC-128 ECDH algorithm. First, it obtains the 32 random bytes victim‚Äôs secret key by calling CryptGenRandom (which uses the CSP handle) . Babuk generates 32 random bytes for the secret key Then , it adjusts the secret key with some ‚Äúmagic‚Äù bytes and uses the curve25519_donna function to derive the victim‚Äôs public key (needed for the decryption) . Finally feeds the attacker‚Äôs public key , which was hardcoded by the ransomware builder, to th e curve25519_donna function , obtaining a shared key. Hashing the result with SHA256 provides the key for encrypting the files with the ChaCha schema . Babuk sets up the cryptographic keys After the set up of the Keys, Babuk creates a structure to hold the encryption meta-data (victim‚Äôs public key and its crc32 checksum) to be saved at the end of the encrypted file and proceeds to encrypt the files differentiating in 3 cases. The following encryption routine fragments compares the result of the SetFilePointerEx function with the hex values 0x1400000 (around 20 MB), 0x500000 (about 5 MB), and 0 bytes to choose the size of the block to be encrypted. Babuk checks the file size against the hardcoded constants But the routine does not change substantially: It always uses ReadFile to read a variable amount of bytes in the target file, then encrypts the bytes by calling chacha_encrypt, and finally moves the pointer forwards. Babuk reads bytes, encrypts, and moves the file pointer Last but not least, the last fragment of the routine appends the meta-data needed to decrypt the file. That is to say: the attackers need to save the victim‚Äôs public key to recover the shared secret and reproduce the symmetric key. Babuk appends the victim‚Äôs public key to the file as metadata Last Remarks Conclusions Babuk is a simple ransomware in that it does not use any obfuscation to hide its IoCs and does not employ any evasion or anti-analysis technique. Moreover, security vendors know it, considering it shares its codebase with several other malicious campaigns; nevertheless, from the analysis, we had the chance to observe how RaaS software executes its TTPs during large-scale campaigns. Yara Rule rule BabukRansomwareV4 { meta: description = \"YARA rule for Babuk Locker v.4 unpacked\" reference = \"https://medium.com/@dbragetti/babuk-v4-ransomware-e3a6a1939162\" author = \"@dbragetti\" date = \"2022-08-10\" rule_version = \"v1\" malware_type = \"Ransomware\" strings: $arg_str1 = \"shares\" wide $arg_str2 = \"paths\" wide $arg_str3 = \"sf\" wide $str0= \"delete shadows /all /quiet\" wide $str2 = \"How To Restore Your Files.txt\" wide $str3 = \"DoYouWantToHaveSexWithCuongDong\" $str4 = \".babyk\" wide $str5 = \"ADMIN$\" wide $pattern1 = {51003a005c00000057003a005c00000045003a005c00000052003a005c00000054003a005c00000059003a005c00000055003a005c00000049003a005c0000004f003a005c00000050003a005c00000041003a005c00000053003a005c00000044003a005c00000046003a005c00000047003a005c00000048003a005c0000004a003a005c0000004b003a005c0000004c003a005c0000005a003a005c00000058003a005c00000043003a005c00000056003a005c00000042003a005c0000004e003a005c0000004d003a005c000000} condition: all of ($str*) and all of ($arg_str*) and all of ($pattern*) } References https://twitter.com/arkbird_solg/status/1345569395725242373 https://mobile.twitter.com/vxunderground/status/1433758742244478982 https://www.mcafee.com/enterprise/en-us/assets/reports/rp-babuk-ransomware.pdf https://blog.cyble.com/2021/07/05/deep-dive-into-builder-of-notorious-babuk-ransomware/" } ]
